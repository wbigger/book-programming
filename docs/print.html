<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tecnologie Informatiche - Programmazione</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Materiale di supporto alle lezioni.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Benvenuti</a></li><li><a href="chap1/00-README.html"><strong aria-hidden="true">2.</strong> Capitolo 1</a></li><li><ol class="section"><li><a href="chap1/01-lightbot.html"><strong aria-hidden="true">2.1.</strong> Lightbot</a></li><li><a href="chap1/02-processing.html"><strong aria-hidden="true">2.2.</strong> Processing</a></li><li><a href="chap1/03-variables.html"><strong aria-hidden="true">2.3.</strong> Variabili</a></li><li><a href="chap1/04-flow.html"><strong aria-hidden="true">2.4.</strong> Controllo di flusso</a></li></ol></li><li><a href="chap2/00-README.html"><strong aria-hidden="true">3.</strong> Capitolo 2</a></li><li><ol class="section"><li><a href="chap2/01-classes.html"><strong aria-hidden="true">3.1.</strong> Classi</a></li><li><ol class="section"><li><a href="chap2/02-improvements.html"><strong aria-hidden="true">3.1.1.</strong> Miglioramenti</a></li></ol></li><li><a href="chap2/03-3D.html"><strong aria-hidden="true">3.2.</strong> Passiamo al 3D</a></li><li><a href="chap2/04-cycles.html"><strong aria-hidden="true">3.3.</strong> Costrutti ciclici</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tecnologie Informatiche - Programmazione</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#fondamenti-di-programmazione" id="fondamenti-di-programmazione"><h1>Fondamenti di programmazione</h1></a>
<p><strong>A.S. 2018-2019</strong></p>
<p><strong>Istituto di Istruzione Superiore G. Marconi</strong></p>
<p><strong>Tecnologie informatiche</strong></p>
<p>Benvenuti ragazzi!</p>
<p>Questo materiale riepiloga quanto detto a lezione.</p>
<p>Le risposte alle domande dei compiti in classe sono tutte incluse in questo materiale.</p>
<p>I riferimenti al libro di testo sono tra parentesi quadre, come ad esempio [pag. 1].</p>
<blockquote>
<p>Il testo in questi box sono per approfondimento. La lettura di questo materiale non è strettamente
necessaria per le verifiche, ma è consigliata per vostra cultura personale e in quanto
sapere indispensabile per chi vuole diventare un informatico.</p>
</blockquote>
<p>Buon studio e buon lavoro.</p>
<a class="header" href="#principi-di-programmazione" id="principi-di-programmazione"><h1>Principi di programmazione</h1></a>
<p>Qual'è il nostro scopo in quanto studenti e futuri informatici?</p>
<p>Questa è una domanda che dobbiamo porci continuamente, dal momento in cui cominciamo a studiare informatica e per tutta la nostra carriera lavorativa.</p>
<p>Probabilmente la risposta più esatta a questa domanda è: <strong>risolvere problemi</strong>.</p>
<p>Non tutti i problemi possono essere risolti con l'informatica ed i computer, o almeno non in maniera semplice e diretta. Noi ci concentreremo su quei problemi che possiamo risolvere, attraverso gli strumenti che piano piano negli anni impareremo ad usare e padroneggiare.</p>
<p>È importante però chiarire fin da subito che noi, in quanto esseri umani, per poter <em>risolvere</em> un problema dobbiamo prima <em>comprenderlo</em> ed essere in grado di <em>condividere</em> il nostro punto di vista con le altre persone coinvolte nel progetto. Nel corso degli ultimi 50 anni in cui si è sviluppata l'ingegneria del software, si è visto statisticamente che il modo più efficace per raggiungere questi obiettivi è attraverso la <em>narrativizzazione</em> dei problemi, in altre parole rappresentare i problemi attraverso delle <strong>storie</strong>. Noi useremo questo approccio durante questo corso e per tutti gli anni a seguire.</p>
<blockquote>
<p>Tradurre i progetti in storie è stato formalizzato in particolare da una metodologia chiamata <em>Agile/Scrum</em>. Per maggiori approfondimenti, potete consultare:</p>
<ul>
<li><a href="http://www.agilemanifesto.org">Agile Manifesto</a> [1994]</li>
<li>il mio corso di <a href="https://wbigger.github.io/book-web-app">Sviluppo Web</a> per il triennio informatico, materia TPSI</li>
<li>il corso su edX di <a href="https://www.edx.org/course/agile-software-development">Agile Software Development</a> (completamente gratuito)</li>
<li>la specializzazione su Coursera di <a href="https://www.coursera.org/specializations/agile-development">Agile Development</a> (materiale accessibile gratuitamente, a pagamento se si richiede la certificazione)</li>
</ul>
</blockquote>
<a class="header" href="#lightbot" id="lightbot"><h1>Lightbot</h1></a>
<p>Per spiegare in maniera pratica cosa intendiamo per risolvere i problemi attraverso storie useremo un'applicazione mobile chiamata <a href="http://lightbot.com/"><strong>LightBot</strong></a>. Potete scaricare l'applicazione sul vostro smartphone attraverso i seguenti link.</p>
<style>
.text-center {
	text-align: center;
}
.button:hover {
    animation-name: rubberBand;
    animation-duration: .35s;
}
@-webkit-keyframes rubberBand {
  0% {transform: scale(1);}
  30% {transform: scaleX(0.95) scaleY(1.05);}
  60% {transform: scaleX(1.05) scaleY(0.95);}
  100% {transform: scale(1);}
}
@keyframes rubberBand {
  0% {transform: scale(1);}
  30% {transform: scaleX(0.95) scaleY(1.05);}
  60% {transform: scaleX(1.05) scaleY(0.95);}
  100% {transform: scale(1);}
}
</style>
<div class="text-center">
        <a href="https://itunes.apple.com/us/app/lightbot-code-hour/id873943739" target="_blank"_>
            <img src="./assets/btn_appstore.png" class="button inline-block">
        </a>
        <a href="https://play.google.com/store/apps/details?id=com.lightbot.lightbothoc" target="_blank"_>
            <img src="./assets/btn_googleplay.png" class="button inline-block">
        </a>
</div>
<blockquote>
<p>Lightbot è pubblicata da <a href="https://code.org">code.org</a>, un'organizzazione nonprofit basata a Seattle (USA) per facilitare l'accesso a scuola della computer science  ed in particolare per incrementare la partecipazione delle donne e minoranze sotto-rappresentate.</p>
</blockquote>
<a class="header" href="#avvio-del-programma" id="avvio-del-programma"><h1>Avvio del programma</h1></a>
<p>Appena aperta l'applicazione di Lightbot, vi comparirà la seguente schermata.</p>
<style>
p img {
  width: 90%;
}
</style>
<p align="center">
<img title="lightbot-start" src="assets/01-lb-start.png">
</p>
<p>Potete scegliere il bot con sembianze femminili cliccando in alto a sinistra e cambiare lingua dall'icona in alto a destra.</p>
<blockquote>
<p>Già da questi particolari potete notare l'attenzione per l'inclusione e la partecipazione di tutti e tutte alla programmazione. Anche noi dobbiamo cercare di mantenere lo stesso livello di inclusione a scuola ed in tutto quello che facciamo!</p>
</blockquote>
<p>Cliccando sull'immagine al centro, cominciamo il nostro viaggio nella programmazione!</p>
<a class="header" href="#il-problema-e-la-storia" id="il-problema-e-la-storia"><h1>Il problema e la storia</h1></a>
<p>Appena avviato il primo livello, subito il nostro bot si presenta e dichiara i suoi obiettivi.</p>
<p align="center">
<img title="lightbot-start" src="assets/02-lb-story.png">
</p>
<p>Possiamo identificare degli elementi fondamentali che caratterizzano <em>tutte le storie</em>:</p>
<ol>
<li><strong>chi ha il problema?</strong></li>
<li><strong>qual'è il problema?</strong></li>
<li><strong>perché lo vuole risolvere?</strong></li>
</ol>
<p>Nel caso di Lightbot, le risposte a queste domande sono:</p>
<ol>
<li>il bot</li>
<li>accendere tutte le mattonelle</li>
<li>per passare al livello successivo</li>
</ol>
<p>Per descrivere un problema si possono mettere questi tre elementi in un unica frase, creando così una <em>storia utente</em>. Nelle storie generalmente si preferisce mettere il <em>verbo in prima persona</em>, ponendo chi ha il problema come soggetto. La nostra storia utente assume la seguente forma:</p>
<p align="center">
<strong>Storia 1</strong>: come bot, voglio accendere tutte le mattonelle per passare al livello successivo
</p>
<p>Bene, abbiamo creato la nostra prima storia 😎.</p>
<blockquote>
<p>Ovviamente possiamo individuare vari livelli di problemi. Ad esempio ci possiamo chiedere perché il bot vuole passare di livello, oppure potremmo dire che siamo noi che vogliamo passare di livello per divertirci o per imparare a programmare.<br>
<br>
Tutte queste considerazioni sono corrette e possono essere prese in considerazione, creando altre storie. Saremo noi programmatori, di volta in volta, a decidere su quale livello di problema lavorare e quali storie prendere in considerazione.</p>
</blockquote>
<a class="header" href="#vincoli-di-progetto" id="vincoli-di-progetto"><h1>Vincoli di progetto</h1></a>
<p>Quando vogliamo risolvere un qualsiasi problema, abbiamo dei limiti che non possiamo superare. Ad esempio potremmo avere denaro o tempo limitati, oppure poca esperienza nel campo o strumenti insufficienti. In ogni caso, per risolvere un problema dobbiamo fare i conti con la nostra realtà, qui e ora. Questi limiti in termine tecnico vengono chiamati <em>vincoli di progetto</em>.</p>
<blockquote>
<p>I vincoli tra di loro sono generalmente collegati: ad esempio con i soldi posso comprare strumenti migliori, oppure con il tempo posso studiare per migliorare le mie capacità. L'importante, quando si affronta un problema, è avere ben chiaro quali sono i vincoli.</p>
</blockquote>
<p>Continuando il tutorial del primo livello, il bot ci presenta quali sono i nostri <strong>strumenti di lavoro</strong>.</p>
<style>
p.two-pane img {
  width: 45%;
}
</style>
<p align="center" class="two-pane">
<img title="lightbot-walk" src="assets/03-lb-command-1.png">
<img title="lightbot-light" src="assets/03-lb-command-2.png">
</p>
<p>Gli strumenti di lavoro compaiono nella parte bassa dello schermo. Possiamo usare ogni strumento quante volte vogliamo, senza che questi finiscano o si consumino.</p>
<p>Arrivati al secondo livello, avremo la seguente schermata.</p>
<p align="center">
<img title="lightbot-screen" src="assets/04-lb-screen.png">
</p>
<p>Nella parte destra dello schermo abbiamo lo spazio per inserire i nostri comandi. Nel gioco non possiamo inserire più comandi di quelli che entrano in queste caselle. Questo spazio possiamo considerarlo il nostro limite di spesa, detto anche <em>budget</em>, oltre il quale non possiamo andare per completare il progetto.</p>
<p>Ricapitolando, finora possiamo individuare due vincoli principali:</p>
<ul>
<li>gli <strong>strumenti</strong> che abbiamo a disposizione</li>
<li>il <strong>budget</strong> che ci è stato assegnato</li>
</ul>
<p align="center">
<img title="lightbot-screen" src="assets/05-lb-constraints.png">
</p>
<p>All'inizio è facile riuscire ad accendere tutte le mattonelle, ma andando avanti le cose diventano più complicate. Ad esempio, uno degli ultimi livelli si presenta così:</p>
<p align="center">
<img title="lightbot-screen" src="assets/06-lb-hard.png">
</p>
<p>Facendo varie prove, si vede presto che il problema è di difficile soluzione perché abbiamo poche caselle a disposizione, in altre parole abbiamo un budget limitato, oppure perché degli strumenti che abbiamo sono insufficienti (sarebbe utile ad esempio un &quot;salta e gira&quot; in un unico comando!). Ma non abbiamo potere su questi vincoli.</p>
<p>A questo punto diventa chiaro l'ultimo vincolo da cui dipende il successo del nostro progetto:</p>
<ul>
<li>le <strong>capacità</strong> del nostro team</li>
</ul>
<p>Per riuscire ad aiutare il bot ad accendere tutte le mattonelle, dobbiamo riflettere, ingegnarci, studiare e chiedere aiuto finché non troviamo la soluzione adatta.</p>
<a class="header" href="#risolvere-un-problema" id="risolvere-un-problema"><h1>Risolvere un problema</h1></a>
<p>Come abbiamo detto all'inizio, non tutti i problemi sono risolvibili. In particolare, quando un problema comincia ad essere difficile ci scontreremo prima o poi con uno dei tre vincoli:</p>
<ul>
<li>non avere abbastanza budget</li>
<li>non avere gli strumenti adatti</li>
<li>non avere capacità sufficienti.</li>
</ul>
<p>Come essere umani, tendiamo spesso a dare troppa importanza al primo vincolo: non sono riuscito a completare il progetto perché non avevo abbastanza tempo, o soldi, o persone nel team. La realtà è però che il budget, per sua natura, è sempre limitato: non potremo mai aumentare all'infinito i nostri soldi, o il tempo, o le persone che lavorano con noi.</p>
<p>Gli altri due vincoli possiamo aumentarli molto di più: trovare strumenti migliori, studiare, aggiornarsi. La storia della tecnologia in fondo è proprio questa: l'essere umano, mantenendo più o meno costante il budget, è riuscito a risolvere straordinari problemi migliorando continuamente gli strumenti e le proprie capacità: procurarsi il cibo, condividere informazioni, arrivare sempre più lontano. Il nostro percorso di studi si concentrerà su questo: trovare gli strumenti più adatti e migliorare le nostre capacità per risolvere i problemi che dovremo affrontare.</p>
<a class="header" href="#processing" id="processing"><h1>Processing</h1></a>
<p>Passiamo ora ad un vero ambiente di programmazione che possiamo usare per risolvere problemi e realizzare progetti di vario tipo: <a href="https://processing.org/"><em>Processing</em></a>.</p>
<blockquote>
<p>Da <a href="https://it.wikipedia.org/wiki/Processing">Wikipedia</a>: <em>&quot;Processing è un linguaggio di programmazione che consente di sviluppare diverse applicazioni come giochi, animazioni, contenuti interattivi e opere d'arte generativa.&quot;</em><br><br>
Per avere un'idea di cosa può essere realizzato con Processing, potete visitare il <a href="http://hello.processing.org/editor/">tutorial ufficiale</a> che contiene video e un editor online.</p>
</blockquote>
<p>Nel caso di Processing, gli strumenti che abbiamo sono le <em>funzioni</em> predefinite, i <em>costrutti</em> del linguaggio ed i <em>paradigmi</em> di programmazione che mette a disposizione.</p>
<a class="header" href="#la-documentazione-un-sito-da-tenere-sempre-a-portata-di-mano" id="la-documentazione-un-sito-da-tenere-sempre-a-portata-di-mano"><h2>La documentazione: un sito da tenere sempre a portata di mano</h2></a>
<ul>
<li>Come si disegna un quadrato?</li>
<li>Come si disegna un cerchio?</li>
<li>Come si disegna un triangolo?</li>
<li>Quali parametri devo mettere?</li>
<li>È possibile disegnare delle linee?</li>
<li>Si può generare un numero casuale?</li>
<li>Si può caricare un'immagine? Quale formato devo usare?</li>
</ul>
<p>La risposta a queste e moltissime altre domande è sempre la stessa: consultare la <em>documentazione</em>, detta anche <a href="https://processing.org/reference/"><em>&quot;Language Reference&quot;</em></a>. Questo sito che descrive nel dettaglio i particolari sull'uso di tutte le caratteristiche del linguaggio. È fondamentale che prendiate confidenza con questo sito, non fatevi spaventare dall'inglese: le parole usate sono più o meno sempre le stesse e la costruzione delle frasi molto semplice. Vedrete che farete pratica in poco tempo, e questa conoscenza vi tornerà utile per tutto il resto della vostra vita.</p>
<blockquote>
<p>Quando si impara un nuovo linguaggio, la prima cosa che un buon programmatore deve avere sempre a portata di mano e con cui deve prendere confidenza è il language reference.</p>
</blockquote>
<blockquote>
<p>Per esercizio, provate a trovare nel language reference di Processing la risposta alle domande all'inizio di questo paragrafo.</p>
</blockquote>
<a class="header" href="#scelta-del-problema-cappucetto-rosso" id="scelta-del-problema-cappucetto-rosso"><h2>Scelta del problema: Cappucetto Rosso</h2></a>
<style>
.left_side {
  float:left;
  margin:5px 20px 0px 5px;
}
p.clear {
  clear: both;  
}
</style>
<p><a href="https://it.wikipedia.org/wiki/Cappuccetto_Rosso#/media/File:Carl_Larsson_-_Little_Red_Riding_Hood_1881.jpg">
<img class="left_side" title="Cappuccetto Rosso e il lupo in un dipinto di Carl Larsson (1881)." alt="cappuccetto-rosso" src="assets/01-pr-cappuccetto.jpg">
</a>
Come abbiamo detto, tutto comincia da un problema. Per poter imparare ad usare Processing, dobbiamo prima trovare un nostro problema da risolvere. Per questo corso useremo il racconto di <a href="https://it.wikipedia.org/wiki/Cappuccetto_Rosso">Cappuccetto Rosso</a> come ispirazione.</p>
<p>In questa favola, tutto comincia con Cappuccetto Rosso che deve andare a consegnare delle focacce alla nonna malata. Possiamo così scrivere la nostra prima <em>storia utente</em>, come abbiamo visto nel capitolo precedente:</p>
<p class="clear"></p>
<p align="center">
<strong>Storia 1</strong>: come Cappuccetto Rosso, voglio raggiungere la casa della nonna al di là del bosco per portarle delle focaccine, perché è malata e non può uscire da sola.
</p>
<p>Cominciamo ora a realizzare passo dopo passo la nostra applicazione, partendo da zero ed arrivando a creare un <em>programma</em> che realizzi la storia appena descritta.</p>
<blockquote>
<p>Il progetto completo di Cappuccetto Rosso svolto in classe lo trovate qui: <a href="https://github.com/wbigger/cappuccettorosso">https://github.com/wbigger/cappuccettorosso</a></p>
</blockquote>
<a class="header" href="#design" id="design"><h2>Design</h2></a>
<p>Il passo successivo alla storia è disegnare come dovrà apparire la nostra applicazione. Possiamo fare un disegno su carta o usando un programma di disegno (es. Gimp, Photoshop), ma la cosa importante è che sia chiaro come deve apparire visivamente l'applicazione e che cosa deve fare. Nel nostro caso, possiamo rappresentare l'applicazione con il seguente schema.</p>
</style>
<p align=center>
<img class="center" alt="design" src="assets/pr-design.png">
</p>
<a class="header" href="#immagini-e-forme" id="immagini-e-forme"><h2>Immagini e forme</h2></a>
<p>Analizziamo gli elementi della nostra storia che dovremo andare a rappresentare sul nostro schermo:</p>
<ul>
<li>Cappuccetto Rosso</li>
<li>la casa della nonna</li>
</ul>
<p>Come rappresentiamo questi elementi? Abbiamo fondamentalmente due possibilità:</p>
<ul>
<li>attraverso un'<em>immagine</em> (in inglese <em>image</em>), caricate ad esempio da un file .png o .jpg (in termine tecnico sono <em>immagini rasterizzate</em>)</li>
<li>attraverso <em>forme</em> (in inglese <em>shape</em>), come ad esempio un insieme di ellissi, rettangoli e triangoli (in termine tecnico sono <em>immagini vettoriali</em>)</li>
</ul>
<p>Possiamo scegliere sia l'una che l'altra strada. In generale, una volta presa una scelta, meglio rimanere su quella strada e rendere tutto coerente, mischiare immagini rasterizzate e forme e mantenere un aspetto gradevole può essere molto difficile.</p>
<p>Per il nostro progetto, scegliamo di usare le <strong>forme</strong>, perché in questo momento sono più semplici da creare e manipolare, e in futuro possiamo usare facilmente delle forme tridimensionali.</p>
<p>Andando a consultare la documentazione per vedere come si disegnano le forme in Processing. Troviamo che quello di cui abbiamo bisogno si chiama <strong>PShape</strong> (abbreviazione di <em>Processing Shape</em>). Fortunatamente Processing mette a disposizione un <a href="https://processing.org/tutorials/pshape/">tutorial</a> completo per il suo utilizzo.</p>
<blockquote>
<p>Per rappresentare immagini si usa invece il tipo <strong>PImage</strong></p>
</blockquote>
<a class="header" href="#variabili" id="variabili"><h1>Variabili</h1></a>
<p>Per rappresentare Cappuccetto Rosso, abbiamo bisogno di riservare un pezzettino della nostra memoria RAM che conterrà tutte le informazioni necessarie per disegnarla, come ad esempio dimensione, colore, etc. per riservare un'area di memoria RAM di questo genere ci serve una <strong>variabile</strong>.</p>
<p>Apriamo l'IDE di Processing, e salviamo il progetto vuoto che ci si presenta con il nome <code>cappuccettorosso</code>.</p>
<p>Nella prima riga, creiamo la nostra prima variabile PShape.</p>
<style>
img.center {
  width: 75%;
}
</style>
<p align=center>
<img class="center" alt="variable-declaration" src="assets/02-pr-var.png">
</p>
<p>Analizziamo nel dettaglio quello che abbiamo appena scritto:</p>
<p align=center>
<img class="center" alt="variable-declaration" src="assets/02-pr-var-c.png">
</p>
<p>La creazione di una variabile in termine tecnico si chiama <strong>dichiarazione</strong>. La dichiarazione ha due componenti:</p>
<ul>
<li>il <strong>tipo</strong> della variabile, che determina la quantità di spazio occupata in memoria e le caratteristiche della variabile</li>
<li>l'<strong>identificativo</strong>, che è il <em>nome</em> con cui nel resto del programma possiamo riferirci alla variabile.</li>
</ul>
<p>È di estrema importanza che l'identificativo sia chiaro ed autoesplicativo: evitate di usare nomi come <code>a</code>, <code>b</code> o simili e preferite i nomi che hanno un senso all'interno della storia in cui vi trovate.</p>
<blockquote>
<p>La favola di Cappuccetto Rosso non sarebbe stata la stessa se la bambina si fosse chiamata <code>a</code> o <code>stivaletti blu</code>!</p>
</blockquote>
<p>Appena dichiarata, la variabile non ha alcun valore significativo. Spesso usare una variabile solo dichiarata porta ad un errore in esecuzione con relativo <em>crash</em> dell'applicazione. Dopo aver dichiarato una variabile bisogna quindi dargli un valore, questa operazione si chiama <strong>assegnazione</strong>.</p>
<p>Assegniamo quindi il valore della nostra variabile nella funzione <code>setup()</code> del nostro programma. La mettiamo in setup perché, una volta assegnata la forma, questa <em>non</em> cambierà per tutto il resto del programma.</p>
<p align=center>
<img class="center" alt="variable-assignment" src="assets/03-pr-assign.png">
</p>
<p>Come vediamo, l'assegnazione si fa usando il segno <code>=</code> e mettendo a sinistra l'identificativo della nostra variabile e a destra il valore che vogliamo assegnare. In questo caso facciamo creare la forma alla funzione <a href="https://processing.org/reference/createShape_.html"><code>createShape()</code></a>, ed in particolare ci facciamo creare un rettangolo che ha inizialmente posizione <code>0,0</code>, altezza <code>30</code> e larghezza <code>30</code>.</p>
<p>Procedendo in maniera simile per la casa, otteniamo il seguente codice:</p>
<pre><code class="language-java">PShape cappuccetto;
PShape house;

void setup() {
  fullScreen(); // usa tutto lo schermo
  cappuccetto = createShape(RECT, 0, 0, 30, 30);
  house = createShape(RECT, 0, 0, 100, 100);
}
</code></pre>
<p>Ora, nella funzione <code>draw()</code>, vogliamo disegnare cappuccetto rosso a sinistra e la casetta della nonna a destra. Sempre consultando la documentazione, scopriamo che per disegnare una forma possiamo usare la funzione <a href="https://processing.org/reference/shape_.html"><code>shape()</code></a>. Esistono diversi modi di usare <code>shape</code>, a noi fa comodo la versione <code>shape(shape, x, y)</code>, in cui possiamo specificare le coordinate <code>x,y</code> in cui andremo a disegnare la forma.</p>
<pre><code class="language-java">void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  //disegniamo cappuccetto rosso a sinistra, a metà altezza dello schermo
  shape(cappuccetto, 10, height*0.5);
}
</code></pre>
<p>Se provate ad eseguire questo codice, avrete una schermata simile alla seguente.</p>
<p align=center>
<img class="center" alt="static-1" src="assets/04-pr-static-1.png">
</p>
<p>Va quasi bene! Dobbiamo però cambiare il colore della bambina in rosso. Come facciamo? Come al solito, andiamo sulla documentazione di <a href="https://processing.org/reference/PShape.html">PShape</a>, scorriamo un po' e scopriamo che esiste un metodo chiamato <code>setFill()</code> che serve proprio per questo.</p>
<blockquote>
<p>Ci sono altre soluzioni per colorare la forma, ad esempio quella che già conosciamo di usare la funzione <code>fill()</code> subito prima di disegnare la forma. Però noi useremo setFill() perché ci permette di colorare la nostra forma senza influenzare il resto del disegno.</p>
</blockquote>
<p>Avendo trovato <code>setFill()</code> <em>dentro</em> la documentazione di PShape, dobbiamo usare una notazione particolare per poterla chiamare:</p>
<pre><code class="language-java">void setup() {
  fullScreen(); // usa tutto lo schermo
  cappuccetto = createShape(RECT, 0, 0, 30, 30);
  cappuccetto.setFill(color(255,0,0)); // riempimento rosso
  house = createShape(RECT, 0, 0, 100, 100);
}
</code></pre>
<p align=center>
<img class="center" alt="static-2" src="assets/04-pr-static-2.png">
</p>
<p>OK! Ora ci rimane solo da far muovere cappuccetto rosso da sinistra a destra. Per fare questo, creiamo una nuova variabile che conterrà la posizione del personaggio. Il <em>tipo</em> di questa variabile è un numero intero, che in Processing si chiama <code>int</code>; come identificativo possiamo usare <code>xCappuccetto</code>, per far capire che è la coordinata <code>x</code> della variabile <code>cappuccetto</code>. Assegniamo anche il valore iniziale 10.</p>
<p align=center>
<img class="center" alt="dich-assign" src="assets/05-pr-dich-assign-c.png">
</p>
<p>Questa volta, per comodità, abbiamo dichiarato la variabile ed assegnato il valore sulla stessa riga, ma ricordiamoci che sono comunque due operazioni differenti.</p>
<p>Per far muovere cappuccetto, sostituamo la coordinata x nella funzione <code>shape()</code> con questa nuova variabile, e ricordiamoci di incrementarla ad ogni ciclo. Il risultato finale è il seguente.</p>
<pre><code class="language-java">PShape cappuccetto;
PShape house;
int xCappuccetto = 10;

void setup() {
  fullScreen(); // usa tutto lo schermo
  cappuccetto = createShape(RECT, 0, 0, 30, 30);
  cappuccetto.setFill(color(255,0,0));
  house = createShape(RECT, 0, 0, 100, 100);
}

void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  //disegniamo cappuccetto a metà altezza dello schermo
  shape(cappuccetto, xCappuccetto, height*0.5);

  // incremento la coordinata x di cappuccetto
  xCappuccetto = xCappuccetto + 5;
}
</code></pre>
<p align=center>
<img class="center" alt="dynamic" src="assets/06-pr-dynamic.gif">
</p>
<p>Mh... Cappuccetto Rosso ora si sposta ma continua anche oltre la casa della nonna...🤔 Dobbiamo aggiungere una condizione che faccia in modo tale che la bambina avanzi solo se ancora non è arrivata alla casa.</p>
<a class="header" href="#controllo-di-flusso-condizioni" id="controllo-di-flusso-condizioni"><h1>Controllo di flusso: condizioni</h1></a>
<p>Per fermare Cappuccetto Rosso solo quando arriva dentro la casa, ci serve di aggiungere una <em>condizione</em>, qualcosa del tipo: <em>se</em> accade questo <em>allora</em> fai questo. In inglese <em>se</em> si traduce con <em>if</em> e allora si traduce con <em>then</em>. La struttura di controllo in programmazione si chiama infatti <em>if-then</em>.</p>
<p>Subito dopo l'<code>if</code> dobbiamo mettere una condizione, ovvero qualcosa che possa essere <strong>vero o falso</strong>. Nel nostro caso vogliamo che l'incremento della posizione di Cappuccetto Rosso avvenga <em>solo se</em> non è ancora arrivata alla casa. Vediamo graficamente le variabili rappresentate sullo schermo.</p>
<p align=center>
<img class="center" alt="conditional" src="assets/06-pr-dynamic-c.png">
</p>
<p>In codice possiamo tradurre il concetto &quot;solo se xCappuccetto è minore di width*0.8, fai avanzare cappuccetto&quot; come segue:</p>
<p align=center>
<img class="center" alt="conditional" src="assets/07-pr-conditional.png">
</p>
<p>Vediamo nel dettaglio queste istruzioni:</p>
<p align=center>
<img class="center" alt="conditional" src="assets/07-pr-conditional-c.png">
</p>
<p>Tutto inizia con <code>if</code>, che è una parola speciale nel linguaggio di Processing, e per questo viene chiamata <strong>keyword</strong>. Subito dopo, tra <strong>parentesi tonde</strong>, c'è la condizione: in questo caso la posizione x di Cappuccetto Rosso deve essere minore di <code>width*0.8</code>, che è esattamente la posizione della casa. Come possiamo vedere, questa condizione può essere solo vera o falsa, non ci sono altre possibilità nel mezzo. Dopo le parentesi tonde ci sono delle <strong>parentesi graffe</strong> che racchiudono le istruzioni da eseguire, solo se la condizione è vera.</p>
<p>Il risultato finale è quello che segue.</p>
<p align=center>
<img class="center" alt="final" src="assets/08-pr-final.gif">
</p>
<p>E questo è il codice relativo.</p>
<pre><code class="language-java">PShape cappuccetto;
PShape house;
int xCappuccetto = 10;

void setup() {
  fullScreen(); // usa tutto lo schermo

  cappuccetto = createShape(RECT, 0, 0, 30, 30);
  cappuccetto.setFill(color(255,0,0));

  house = createShape(RECT, 0, 0, 100, 100);
}

void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  //disegniamo cappuccetto a metà altezza dello schermo
  shape(cappuccetto, xCappuccetto, height*0.5);

  // incremento la coordinata x di cappuccetto
  // solo se non è ancora nella casa della nonna
  if (xCappuccetto &lt; width*0.8) {
    xCappuccetto = xCappuccetto + 5;
  }
}
</code></pre>
<a class="header" href="#fondamenti-di-programmazione-1" id="fondamenti-di-programmazione-1"><h1>Fondamenti di programmazione</h1></a>
<p>Ora che abbiamo visto alcune basi teoriche della programmazione, andiamo avanti e vediamo quali sono i mattoncini fondamentali che ci serviranno per costruire in pratica le nostre applicazioni.</p>
<p>Un paio di elementi li abbiamo già visti:</p>
<ul>
<li>le variabili: un'area di memoria RAM su cui possiamo operare</li>
<li>i controllori di flusso condizionali (<code>if</code>): ci permettono di eseguire un'operazione oppure un'altra in base ad una condizione.</li>
</ul>
<p>In questo capitolo affronteremo altri concetti fondamentali, come quello di classe, attributi e metodi.</p>
<style>
img.center {
  width: 75%;
}
</style>
<a class="header" href="#le-classi" id="le-classi"><h1>Le classi</h1></a>
<p>Abbiamo detto che un linguaggio di programmazione ci serve per risolvere problemi nel mondo reale. Per poter svolgere correttamente il suo lavoro, il linguaggio deve permetterci di rappresentare facilmente i concetti del mondo reale a cui facciamo riferimento.</p>
<p>Ad esempio, nel mio progetto ora ho le variabili cappuccetto rosso e la casa della nonna. Guardando semplicemente il codice, le variabili <code>cappuccetto</code> e <code>house</code> sono create ed usate in modo molto simile, non sono legate ad un concetto particolare distinto. L'unica cosa che differenzia le due variabili è il nome, a cui il programmatore umano sa dare un senso, ma per il computer  (in questo caso il <strong>compilatore</strong>) i nomi delle variabili sono semplicemente un insieme di caratteri senza un particolare significato.</p>
<blockquote>
<p>Il <strong>compilatore</strong> è il software che interpreta il codice che abbiamo scritto e lo traduce in linguaggio macchina. Se ci sono degli errori di sintassi nel nostro codice, il compilatore non riuscirà ad interpretarlo correttamente e ci restituirà un errore.</p>
</blockquote>
<p>Si possono dare maggiori indizi al compilatore (e ai programmatori del mio team) per poter gestire meglio i diversi tipi di variabili?</p>
<p>La risposta è <em>sì</em>, e il modo in cui si fa è tramite la creazione di nuovi assegnare <em>tipi</em> da assegnare alle variabili. Ad esempio possiamo dire che <code>cappuccetto</code> è una Bambina, o un Personaggio della mia storia, o quello che vogliamo.</p>
<blockquote>
<p>Analogamente, <code>house</code> potrebbe essere di <em>tipo</em> <code>Edificio</code>.</p>
</blockquote>
<p>Come facciamo in pratica a fare una cosa del genere? Per creare nuovi tipi in Processing il modo più semplice è dichiarare una <em>classe</em>.</p>
<a class="header" href="#classi" id="classi"><h2>Classi</h2></a>
<p>Le classi in informatica sono come degli <em>stampini</em> che servono per creare degli <em>oggetti</em>. Rivediamo un attimo l'attività che abbiamo fatto in classe.</p>
<p align="center">
<img class="center" title="Esempi di _oggetti_ creati con uno stampino _classe_." alt="classes" src="assets/classes.jpg">
</p>
<p>Gli stampini che avete usato avevano una forma ben definita: aereo, squalo, numero, etc. Potevate usare ogni stampino per creare tanti <em>oggetti dello stesso tipo</em>, ad esempio tanti aerei. Gli oggetti così creati saranno tutti molto simili fra loro, ma non perfettamente uguali: nel momento della creazione o dopo averlo stampato, possiamo modificarli un pochino.</p>
<blockquote>
<p>Un vantaggio di usare questi stampini/classi è che possiamo creare velocemente degli oggetti simili tra di loro. Lo svantaggio è, che se dobbiamo modificare molto l'oggetto dopo la crezione, le cose cominciano a diventare complicate. Non c'è una regola assoluta per la scelta: in generale, cercate di mantenere il <em>senso</em> di quello che state facendo: non cercate di trasformare la formina di un aereo in un pesce, o viceversa.</p>
</blockquote>
<a class="header" href="#dichiarazione-di-una-classe" id="dichiarazione-di-una-classe"><h2>Dichiarazione di una classe</h2></a>
<p>Ipotizziamo che, nel nostro progetto, vogliamo che cappuccetto rosso sia un Personaggio. Per prima cosa, definiamo un nuovo tipo.</p>
<pre><code class="language-java">class Personaggio {}
</code></pre>
<p>Vediamo bene la sintassi, in ordine da sinistra a destra:</p>
<ul>
<li>la keyword <code>class</code>, che dichiara una nuova classe</li>
<li>l'<em>identificativo</em> della classe, in questo caso la <code>Personaggio</code></li>
<li>le parentesi graffe, che rappresentano il <em>corpo</em> (in inglese <em>body</em>) della classe</li>
</ul>
<p>Proviamo ad usare questo nuovo tipo.</p>
<pre><code class="language-java">class Personaggio {};
Personaggio cappuccetto;
</code></pre>
<p>OK, abbiamo fatto in modo di esplicitare che cappuccetto rosso non è una forma qualsiasi, ma un Personaggio!</p>
<p>A questo punto però, se proviamo a compilare il programma, ci restituisce un errore quando proviamo ad assegnare <code>cappuccetto</code> con <code>createShape(...)</code>. L'errore è il seguente:</p>
<pre><code>Type mismatch, &quot;PShape&quot; does not match with &quot;Personaggio&quot;.
</code></pre>
<p>Perché questa cosa? Riflettiamo: stiamo provando ad assegnare alla nostra variabile <code>cappuccetto</code> una forma, ma adesso il tipo è cambiato, e il compilatore non sa come assegnare una forma ad un personaggio. È giunto il momento di scrivere qualcosa nel corpo della classe.</p>
<a class="header" href="#costruttore" id="costruttore"><h3>Costruttore</h3></a>
<p>Per prima cosa, dobbiamo dire che il nostro personaggio ha una forma. Inseriamo quindi all'interno della classe la dichiarazione di una variabile forma:</p>
<pre><code class="language-java">class Personaggio {
  PShape forma;
};
</code></pre>
<p>Guardate bene: abbiamo dichiarato una variabile di tipo forma <em>dentro</em> la classe personaggio. Bisogna quindi tenere in considerazione che:</p>
<ul>
<li>si può usare questa variabile solo se si sta utilizzando un personaggio</li>
<li>ogni personaggio avrà una forma diversa</li>
</ul>
<p>Finora abbiamo <em>dichiarato</em> la variabile <code>forma</code>, ma quando la assegniamo? L'assegnazione delle variabili della classe di solito avviene all'interno di una funzione speciale, chiamata <em>costruttore</em>. Questa funzione ha lo stesso nome della classe, e non bisogna specificare il valore di ritorno.</p>
<pre><code class="language-java">class Personaggio {
  PShape forma;
  Personaggio() { // questo è il costruttore!
    // qui dentro ci mettiamo quello che ci serve per inizializzare il nostro oggetto
    forma = createShape(RECT, 0, 0, 30, 30);
  }
};
</code></pre>
<p>Ora dobbiamo andare ad assegnare il valore corretto alla variabile <code>cappuccetto</code>. Questo si fa tramite una nuova keyword: <code>new</code>.</p>
<pre><code class="language-java">void setup() {
  // ...
  // Utilizziamo la keyword new per &quot;stampare&quot; un nuovo oggetto dalla classe
  cappuccetto = new Personaggio();
}
</code></pre>
<p>OK, ora non abbiamo più l'errore di prima ma ne è comparso un altro per riga dopo:</p>
<pre><code class="language-java">cappuccetto.setFill(color(255,0,0));
</code></pre>
<pre><code>The function &quot;setFill(int)&quot; does not exist.
</code></pre>
<p>Perché questo? Cerchiamo di capire bene: abbiamo utilizzato il simbolo punto (<code>.</code>) subito dopo la variabile <code>cappuccetto</code>. Cosa significa questo punto? Risposta: significa che stiamo andando a richiamare variabili e funzioni <em>all'interno</em> della classe di cui fa parte cappuccetto, in questo caso <code>Personaggio</code>. In effetti, se andiamo a vedere dentro la classe c'è solo il costruttore,  non esiste un metodo <code>setFill()</code>.</p>
<p>Ci sono varie soluzioni possibili: una potrebbe essere creare il metodo che ci serve. Per ora però usiamo una strategia diversa: visto che il <code>setFill()</code> fa parte della creazione del personaggio, spostiamo questo metodo dentro il costruttore della classe:</p>
<pre><code class="language-java">class Personaggio {
  PShape forma;
  Personaggio() {
    forma = createShape(RECT, 0, 0, 30, 30);
    forma.setFill(color(255,0,0));
  }
};
</code></pre>
<p>Fate attenzione: abbiamo richiamato <code>setFill()</code> sulla variabile <code>forma</code>, perché all'interno della classe, è questa variabile a dover cambiare colore.</p>
<p>OK, anche questo errore è risolto. Ma ne abbiamo ancora uno (l'ultimo, per fortuna):</p>
<pre><code class="language-java">shape(cappuccetto, xCappuccetto, height*0.5);
</code></pre>
<pre><code>The function &quot;shape()&quot; expects parameters like: &quot;shape(PShape,  float,  float)&quot;
</code></pre>
<p>Questo perché la funzione <code>shape()</code> si aspetta come primo parametro una variabile di tipo <code>PShape</code>, ma noi gli stiamo passando una variabile di tipo <code>Personaggio</code>.</p>
<p>Per risolvere questo problema, possiamo creare una funzione <code>disegna()</code> dentro la classe Personaggio, che, come dice il nome, disegna il nostro personaggio. Proviamo.</p>
<pre><code class="language-java">class Personaggio {
  //...
  void disegna() {
    shape(forma, xCappuccetto, height*0.5);
  }
};

void draw() {}
  // ...
  // chiamiamo il nuovo metodo disegna()
  cappuccetto.disegna();
}
</code></pre>
<p>OK, ora funziona tutto!</p>
<p>Scriviamo di seguito il codice completo, per riferimento.</p>
<pre><code class="language-java">Personaggio cappuccetto;
PShape house;
int xCappuccetto = 10;

class Personaggio {
  PShape forma;
  Personaggio() {
    forma = createShape(RECT, 0, 0, 30, 30);
    forma.setFill(color(255,0,0));
  }
  void disegna() {
    shape(forma, xCappuccetto, height*0.5);
  }
};

void setup() {
  fullScreen(); // usa tutto lo schermo

  cappuccetto = new Personaggio();

  house = createShape(RECT, 0, 0, 100, 100);
}

void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  //disegniamo cappuccetto a metà altezza dello schermo
  cappuccetto.disegna();
  // incremento la coordinata x di cappuccetto
  // solo se non è ancora nella casa della nonna
  if (xCappuccetto &lt; width*0.8) {
    xCappuccetto = xCappuccetto + 5;
  }
}
</code></pre>
<style>
img.center {
  width: 75%;
}
</style>
<a class="header" href="#miglioramenti" id="miglioramenti"><h1>Miglioramenti</h1></a>
<p>Ci sono dei miglioramenti che possiamo fare al codice scritto finora, per renderlo più generale e facilmente utilizzabile.</p>
<a class="header" href="#parametri-del-costruttore" id="parametri-del-costruttore"><h2>Parametri del costruttore</h2></a>
<p>Guardiamo da vicino il costruttore della nostra classe:</p>
<pre><code class="language-java">Personaggio() {
  forma = createShape(RECT, 0, 0, 30, 30);
  forma.setFill(color(255,0,0));

}
</code></pre>
<p>La classe <code>Personaggio</code> in questo momento crea tutti oggetti con la forma di un quadrato 30x30 di colore rosso. Se volessimo creare dei personaggi di forma e colore diverso? Voler generalizzare una funzione è un problema comune e la soluzione è semplice: possiamo <em>parametrizzare</em> la funzione, rendendola più generica.</p>
<blockquote>
<p>Questa tecnica la applicheremo al costruttore ma si può utilizzare per qualsiasi funzione.</p>
</blockquote>
<p>Dobbiamo fare i seguenti passi:</p>
<ol>
<li>creare dei parametri all'interno delle parentesi tonde nella dichiarazione della funzione, specificando <em>tipo</em> e <em>nome</em> del parametro</li>
<li>sostituire i valori costanti all'interno della funzione con il nuovo parametro</li>
<li>aggiungere i parametri necessari quando viene chiamata la funzione</li>
</ol>
<p>Nel nostro caso, ipotizziamo di voler avere la possibilità cambiare la dimensione ed il colore del personaggio:</p>
<ol>
<li>aggiungo i parametri nella dichiarazione del costruttore:</li>
</ol>
<pre><code class="language-java">Personaggio(float siz, color col) {
   //...
}
</code></pre>
<ol start="2">
<li>sostituisco le costanti con i nuovi all'interno della funzione:</li>
</ol>
<pre><code class="language-java">Personaggio(float siz, color col) {
    forma = createShape(RECT, 0, 0, siz, siz);
    forma.setFill(col);
}
</code></pre>
<ol start="3">
<li>aggiungo i parametri necessari quando creo l'oggetto:</li>
</ol>
<pre><code class="language-java">cappuccetto = new Personaggio(30, color(255,0,0));
</code></pre>
<p>Ora posso creare nuovi personaggi con forma e colore diverso, semplicemente cambiando i parametri quando creo l'oggetto.</p>
<a class="header" href="#variabili-di-posizione" id="variabili-di-posizione"><h2>Variabili di posizione</h2></a>
<p>C'è ancora qualcosa che posso migliorare. Ragionandoci, la variabile <code>xCappuccetto</code> rappresenta la posizione del personaggio di cappuccetto rosso, e quindi fa parte delle caratteristiche del personaggio. Se in seguito dovessi creare il personaggio della nonna, vorrei che anche lei avesse una propria posizione.</p>
<p>Sposto quindi la variabile <code>xCappuccetto</code> da fuori a <em>dentro</em> la classe <code>Personaggio</code>, cambiandogli nome nel più generico <code>x</code>.</p>
<pre><code class="language-java">class Personaggio {
  //...
  int x = 10; // tutti i personaggi iniziano dalla posizione 10
  // ...
}
</code></pre>
<p>Quando disegno il personaggio, sostituisco la variabile di posizione con questa nuova:</p>
<pre><code class="language-java">class Personaggio {
  //...
  void disegna() {
      shape(forma, x, height*0.5);
  }
}
</code></pre>
<p>Infine, quando cambio la posizione del personaggio, devo ricordarmi di sostituire la vecchia variabile con la nuova:</p>
<pre><code class="language-java">if (cappuccetto.x &lt; width*0.8) {
    cappuccetto.x = cappuccetto.x + 5;
  }
</code></pre>
<p>Come potete vedere, anche in questo caso ho usato la notazione con il punto per accedere alla variabile interna alla classe.</p>
<a class="header" href="#codice-finale" id="codice-finale"><h2>Codice finale</h2></a>
<p>Di seguito il codice completo finora.</p>
<pre><code class="language-java">Personaggio cappuccetto;
PShape house;


class Personaggio {
  PShape forma;
  int x = 10;
  Personaggio(float siz, color col) {
    forma = createShape(RECT, 0, 0, siz, siz);
    forma.setFill(col);
  }
  void disegna() {
    shape(forma, x, height*0.5);
  }
};

void setup() {
  fullScreen(); // usa tutto lo schermo

  cappuccetto = new Personaggio(30, color(255,0,0));

  house = createShape(RECT, 0, 0, 100, 100);
}

void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  cappuccetto.disegna();
  // incremento la coordinata x di cappuccetto
  // solo se non è ancora nella casa della nonna
  if (cappuccetto.x &lt; width*0.8) {
    cappuccetto.x = cappuccetto.x + 5;
  }
}
</code></pre>
<style>
img.center {
  width: 75%;
}
img.center-100 {
  width: 100%;
}

</style>
<a class="header" href="#passiamo-al-3d" id="passiamo-al-3d"><h1>Passiamo al 3D</h1></a>
<p>Finora abbiamo usato Processing per disegnare in due dimensioni: rettangoli, quadrati, ellissi, etc. E se volessimo disegnare in tre dimensioni, come ad esempio cubi, sfere o forme più complesse?</p>
<p>Passare al 3D con Processing è molto semplice, in quanto questo linguaggio è nato in realtà proprio per rendere semplice la creazione di applicazioni in tre dimensioni. Seguiremo ora passo passo le operazioni da fare per passare dal 2D al 3D.</p>
<a class="header" href="#dichiariamo-di-voler-utilizzare-le-funzionalità-3d" id="dichiariamo-di-voler-utilizzare-le-funzionalità-3d"><h2>Dichiariamo di voler utilizzare le funzionalità 3D</h2></a>
<p>Prima di tutto dobbiamo dichiarare esplicitamente che vogliamo utilizzare le funzionalità 3D di Processing. Questo va fatto aggiungendo il parametro <code>P3D</code> alla funzione <code>fullScreen()</code> o alla funzione<code>size()</code>.</p>
<pre><code class="language-java">void setup() {
  fullScreen(P3D);
  //...
}
</code></pre>
<a class="header" href="#carichiamo-un-modello-3d" id="carichiamo-un-modello-3d"><h2>Carichiamo un modello 3D</h2></a>
<p>Ora che siamo in 3D, possiamo caricare modelli tridimensionali. Processing attualmente supporta unicamente il formato <code>.obj</code>, quindi dobbiamo fare attenzione a cercare dei modelli in questo formato o a convertirlo opportunamente, ad esempio con <a href="https://www.blender.org">Blender</a>.</p>
<blockquote>
<p>Per convertire un file con Blender, aprire un nuovo progetto, eliminare il cubo di default, importare il file dal formato di origine (es. <code>.fbx</code>, <code>.stl</code>, <code>.gltf</code>), eventualmente modificarlo come necessario (rotazione, scalatura, etc.), quindi esportarlo in formato <code>.obj</code>.</p>
</blockquote>
<p>Per il nostro esempio, useremo un modello di Cappuccetto Rosso disponibile qui: <a href="https://raw.githubusercontent.com/wbigger/book-programming/master/src/cappuccetto.obj">cappuccetto.obj</a>. Scaricate il file e salvatelo all'interno della vostra cartella di progetto, nella sottocartella <code>data/</code>.</p>
<p>L'organizzazione dei file e delle cartelle deve essere il seguente:</p>
<p align="center">
<img class="center-100" title="Struttura dei file di un progetto con modelli 3D" alt="folder structure" src="assets/file-structure.png">
</p>
<p>Adesso, per importare il modello, dobbiamo usare la funzione <code>loadShape()</code>:</p>
<pre><code class="language-java">forma = loadShape(&quot;cappuccetto.obj&quot;);
</code></pre>
<p>Attenzione: anche in questo caso, parametrizziamo il costruttore per fare in modo di scegliere nel momento in cui viene creato l'oggetto, quale modello si vuole importare. In questo caso, <code>&quot;cappuccetto.obj&quot;</code> è di tipo stringa, quindi il nostro costruttore diventerà:</p>
<pre><code class="language-java">Personaggio(String filename, color col) {
    forma = loadShape(filename);
    forma.setFill(col);
}
</code></pre>
<p>e per creare l'oggetto scriveremo:</p>
<pre><code class="language-java">cappuccetto = new Personaggio(&quot;cappuccetto.obj&quot;, color(255,0,0));
</code></pre>
<p>Se eseguiamo il nostro progetto, otterremo una cosa del genere:</p>
<p align="center">
<img class="center" title="Cappuccetto rosso: primo tentativo" alt="cappuccetto flat" src="assets/cappuccetto-light-off.png">
</p>
<p>Va quasi bene, ma il nostro modello sembra un po' troppo &quot;piatto&quot;. In effetti, di default Processing mostra solo l'ombra del nostro modello. Per visualizzare qualcosa di più tridimensionale, dobbiamo &quot;accendere le luci&quot; attraverso la funzione <code>lights()</code> da chiamare all'interno di <code>draw()</code>.</p>
<pre><code class="language-java">void draw() {
  background(#00FF00);
  lights();
  //...
}
</code></pre>
<p>Ora otteniamo qualcosa del genere:</p>
<p align="center">
<img class="center" title="Cappuccetto rosso: secondo tentativo" alt="cappuccetto3D" src="assets/cappuccetto.png">
</p>
<p>Bene, era quello che volevamo!</p>
<a class="header" href="#nota-sulla-direzione-degli-assi" id="nota-sulla-direzione-degli-assi"><h2>Nota sulla direzione degli assi</h2></a>
<p>Di default, Processing ha l'asse z rivolto verso il basso. Questa convenzione è opposta a quella usata comunemente, in cui l'asse z punta verso l'alto.</p>
<p>Per risolvere il problema, ci sono varie soluzioni. Per ora ve ne consiglio due:</p>
<ul>
<li>modificare l'orientamento dell'<code>.obj</code>, ad esempio con Blender potete usare la combinazione di tasti r-x-180-invio</li>
<li>ruotare il modello da dentro Processing di 180 gradi attorno all'asse X, subito dopo aver caricato il modello; il comando è quindi <code>.rotateX(radians(180))</code></li>
</ul>
<style>
.left_side {
  float:left;
  margin:5px 20px 0px 5px;
}
.right_side {
  float:left;
  margin:5px 20px 0px 5px;
}
p.clear {
  clear: both;  
}
</style>
<a class="header" href="#costrutti-ciclici" id="costrutti-ciclici"><h1>Costrutti ciclici</h1></a>
<p>Cappuccetto Rosso deve passare attraverso una foresta, ma finora nella nostra applicazione c'è solo un grande prato. Come facciamo a disegnare tanti alberi?</p>
<p><img class="right_side" title="La foresta nera" alt="La foresta nera" src="assets/foresta-nera.jpg" width="20%"></p>
<p>Cappuccetto Rosso è una storia popolare di varie parti del mondo, ma possiamo far riferimento alla versione dei Fratelli Grimm ed immaginarci che la bambina debba attraversare la foresta nera, formata da una fitta vegetazione di abeti. Per cominciare, proviamo a disegnare la foresta con gli strumenti che abbiamo visto finora.</p>
<p class="clear"></p>
<a class="header" href="#definizione-classe-pianta" id="definizione-classe-pianta"><h2>Definizione classe Pianta</h2></a>
<p>Come abbiamo fatto finora, creiamo una nostra classe <code>Pianta</code> per rappresentare un albero.</p>
<blockquote>
<p>Abbiamo scelto <code>Pianta</code> ma anche <code>Albero</code> o <code>Abete</code> potrebbero delle scelte accettabili. La scelta dipende molto da cosa immaginiamo possa servirci in futuro. In ogni caso, l'importante è che la scelta sia sensata <em>adesso</em>, poi se serve possiamo cambiare nome (questa operazione si chiama <em>refactoring</em>). Da evitare assolutamente invece mettere un nome che al momento non ha molto senso perché prevediamo che possa averlo in futuro; in questo modo infatti stiamo creando un programma inconsistente, con probabili conseguenze catastrofiche.</p>
</blockquote>
<p>Che caratteristiche ha la nostra pianta? Ha sicuramente una forma ed una posizione nella foresta; inoltre vogliamo che le diverse piante abbiano una dimensione diversa, quindi aggiungiamo anche un attributo per la dimensione. Altra domanda: cosa possiamo fare con la nostra pianta? Diciamo che possiamo seminarla per farla comparire nella nostra foresta.</p>
<p>Ecco quindi una possibile definizione di questa classe.</p>
<pre><code class="language-java">class Pianta {
  PShape forma;
  float x, y;
  float dimensione;

  Pianta(String piantaObj) {
    // assegniamo la dimensione in modo casuale
    dimensione = random(30, 80);
    // carichiamo il modello della nostra pianta, passandogli come parametro il file con il modello
    forma = loadShape(piantaObj);
    // scaliamo l'oggetto
    forma.scale(dimensione);
    // ruotiamolo lungo l'asse X per rispettare le convenzioni di Processing
    forma.rotateX(radians(180));
    // ruotiamolo casualmente lungo l'asse verticale, per dare un po' di vivacità alla foresta
    forma.rotateY(radians(random(-45,45)));

    // opzionale: coloriamo la pianta di verde. Utile se il modello non è già colorato di suo
    forma.setFill(#28C61E);

    // assegniamo una posizione casuale nello schermo
    x = random(0, width);
    y = random(0, height);
    // spostiamo la pianta nella nuova posizione
    forma.translate(x,y);
  }


  void semina() {
    // disegniamo la pianta
    shape(forma);
  }
}
</code></pre>
<p>OK, ora abbiamo la nostra pianta.</p>
<a class="header" href="#metodo-senza-cicli" id="metodo-senza-cicli"><h2>Metodo senza cicli</h2></a>
<p>Immaginiamo di voler aggiungere 3 alberi. Come già sappiamo fare, creiamo tre variabili e gli assegniamo degli alberi.</p>
<pre><code class="language-java">// Dichiarazione delle variabili
Pianta abete0;
Pianta abete1;
Pianta abete2;

void setup() {
  // [...]
  // Assegnazione delle variabili
  abete0 = new Pianta(&quot;abete.obj&quot;);
  abete1 = new Pianta(&quot;abete.obj&quot;);
  abete2 = new Pianta(&quot;abete.obj&quot;);
}

void draw() {
  // [...]
  // Disegno gli alberi
  abete0.semina();
  abete1.semina();
  abete2.semina();
}
</code></pre>
<p>Questo metodo funziona se abbiamo pochi alberi da disegnare. Ma se ne volessimo disegnare tanti, diventerebbe molto scomodo!</p>
<p>Per risolvere questo problema dobbiamo usare due strumenti: gli array e i cicli. Cominciamo dai primi.</p>
<a class="header" href="#array" id="array"><h2>Array</h2></a>
<p>Sarebbe utile se potessimo dichiarare una sola variabile che contiene tutti gli alberi da disegnare, invece di averne tante tutte simili. Questo in programmazione si può fare attraverso uno strumento che si chiama <em>array</em>.</p>
<p>In Processing (ovvero in Java) gli array sono una sequenza di oggetti tutti dello stesso tipo. Per dichiarare un array usiamo la seguente sintassi.</p>
<pre><code class="language-java">// Dichiarazione array
Pianta[] arrayAbeti;
</code></pre>
<p>Come si vede, aggiungendo le parentesi quadre dopo il tipo base, la variabile dichiarata diventa un <em>array di piante</em>; in altre parole, un insieme ordinato di piante. Per ordinato intendiamo che le piante sono in sequenza: esiste una pianta <code>0</code> che viene prima della pianta <code>1</code> e così via.</p>
<p>Per assegnare la variabile, usiamo invece questa sintassi.</p>
<pre><code class="language-java">void setup() {
  // [...]

  // Assegnazione array
  arrayAbeti = new Pianta[3];
}
</code></pre>
<p>Massima attenzione a questa sintassi. Notiamo prima di tutto che nell'assegnazione dobbiamo ripetere la notazione con il tipo e le parentesi quadre. In questo caso però, nelle parentesi aggiungiamo anche il numero di oggetti che vogliamo mettere nel nostro array, in questo caso tre.</p>
<p>Fate attenzione che questa assegnazione crea l'array, ovvero il contenitore, ma non i singoli alberi. Per creare i singoli alberi, dobbiamo comunque fare un assegnazione per ogni elemento dell'array.</p>
<pre><code class="language-java">// Dichiarazione array
void setup() {
  // [...]
  // Assegnazione array
  arrayAbeti = new Pianta[3];
  // Assegnazione singole piante
  arrayAbeti[0] = new Pianta(&quot;abete.obj&quot;);
  arrayAbeti[1] = new Pianta(&quot;abete.obj&quot;);
  arrayAbeti[2] = new Pianta(&quot;abete.obj&quot;);
}
</code></pre>
<p>Fate attenzione che, convenzionalmente, il primo elemento dell'array è identificato con l'indice <code>0</code>. Ne segue che l'ultimo elemento sarà identificato con l'indice <code>n-1</code>, dove <code>n</code> è la lunghezza dell'array. Nel nostro caso <code>n</code> è 3 e quindi l'ultimo elemento avrà indice <code>2</code>.</p>
<p>Finora la situazione non è che sia migliorata molto, ma ora dobbiamo mettere in campo l'altro strumento: i cicli</p>
<a class="header" href="#ciclo-for-classico" id="ciclo-for-classico"><h1>Ciclo for classico</h1></a>
<p>Osserviamo bene queste righe:</p>
<pre><code class="language-java">arrayAbeti[0] = new Pianta(&quot;abete.obj&quot;);
arrayAbeti[1] = new Pianta(&quot;abete.obj&quot;);
arrayAbeti[2] = new Pianta(&quot;abete.obj&quot;);
</code></pre>
<p>Notiamo che sono quasi del tutto identiche, tranne che per il numero dentro le parentesi quadre. Come facciamo a mettere a fattor comune la parte che si ripete? Con i cicli!</p>
<p>Ricapitoliamo cosa dobbiamo fare: ripetere un istruzione per ogni (in inglese <code>for</code>) valore di un intero che varia da 0 a 2, incrementando ogni volta l'indice di una unità. Mettendo insieme queste cose, veniamo alla formulazione classica del ciclo for:</p>
<pre><code class="language-java">for(int index = 0; index &lt; 3; index = index + 1) {
  arrayAbeti[index] = new Pianta(&quot;abete.obj&quot;);
}
</code></pre>
<p>Ora possiamo aumentare il nostro numero di alberi semplicemente cambiando il valore 3 nell'assegnazione dell'array e nel ciclo. Ottimo!</p>
<p>Nota: possiamo migliorare leggermente il codice qui sopra, per evitare di sbagliare la dimensione dell'array con conseguenze spesso disastrose. Al posto del valore <code>3</code>, possiamo mettere <code>arrayAbeti.length</code>, che ci restituisce sempre il valore corretto della lunghezza dell'array. Miglioriamo quindi il ciclo scritto qui sopra nel seguente modo:</p>
<pre><code class="language-java">for(int index = 0; index &lt; arrayAbeti.length; index = index + 1) {
  arrayAbeti[index] = new Pianta(&quot;abete.obj&quot;);
}
</code></pre>
<a class="header" href="#enhanced-for-loop" id="enhanced-for-loop"><h1>Enhanced for loop</h1></a>
<p>Il caso particolare per cui dobbiamo ripetere delle istruzioni per tutti gli elementi di un array è molto comune e per questo Processing (ovvero Java) prevedono un costrutto particolare, più chiaro e conciso.</p>
<pre><code class="language-java">for (Pianta abete: arrayAbeti) {
  abete.semina();
}
</code></pre>
<p>Questo <code>for</code> chiama la funzione <code>.semina()</code> per tutti gli elementi dell'array. Come vedete, rispetto alla sintassi classica, questa versione &quot;migliorata&quot; (<em>enhanced</em>) è più breve, non rischiamo di sbagliare il valore di inizio o fine dell'indice e, soprattutto, rendiamo esplicito che vogliamo fare un'iterazione su un array. Questo è utile sia per gli altri sviluppatori, per comprendere meglio quello che sta facendo il codice, sia per il compilatore che in questo modo ha maggiori possibilità di ottimizzare il codice e renderlo più veloce.</p>
<a class="header" href="#codice-finale-1" id="codice-finale-1"><h1>Codice finale</h1></a>
<pre><code class="language-java">Personaggio cappuccetto;

class Personaggio {
  PShape forma;
  // costruttore, chiamato quando viene usato &quot;new&quot;
  Personaggio(String filename) {
    forma = loadShape(filename);
    forma.setFill(color(255, 0, 0));
  }

  void disegna(float x, float y) {
    shape(forma, x, y);
  }
}

PShape house;
int xCappuccetto = 150;
// Dichiarazione array
Pianta[] arrayAbeti;

void setup() {
  fullScreen(P3D); // usa tutto lo schermo

  cappuccetto = new Personaggio(&quot;cappuccetto.obj&quot;);
  cappuccetto.forma.rotateX(radians(180));

  house = createShape(RECT, 0, 0, 100, 100);

  // Assegnazione array
  arrayAbeti = new Pianta[3];

  // Assegnazione singole piante
  for (int index = 0; index &lt; arrayAbeti.length; index = index + 1) {
    arrayAbeti[index] = new Pianta(&quot;abete.obj&quot;);
  }
}

void draw() {
  background(#00FF00); // siamo nella foresta, lo sfondo è verde

  // accendiamo le luci per vedere gli oggetti in 3D
  lights();



  //disegniamo la casa a destra, a metà altezza dello schermo
  shape(house, width*0.8, height*0.5);

  //disegniamo cappuccetto a metà altezza dello schermo
  cappuccetto.disegna(xCappuccetto, height*0.5);

  // incremento la coordinata x di cappuccetto
  // solo se non è ancora nella casa della nonna
  if (xCappuccetto &lt; width*0.8) {
    xCappuccetto = xCappuccetto + 5;
  }

  for (Pianta abete : arrayAbeti) {
    abete.semina();
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
